{$IFNDEF WL_ALCHEMY_HANDLER_INCLUDED}
{$DEFINE WL_ALCHEMY_HANDLER_INCLUDED}

{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

{$I types.simba}
{$I config.simba}

(*
  AlchemyHandler.simba
  ====================
  Contains the core alchemy handler logic for item selection and spell casting
*)

// Get the item to alch from inventory
function TRSAlchHandler.GetAlchItem(): TRSItem;
var
  match: TRSItemFinderMatch;
  itemStr: String;
begin
  if DebugState then
    Self.DebugLn('GetAlchItem: Opening inventory and deselecting slots...');
    
  if not Inventory.Open() and not Inventory.SetSelectedSlot(-1) then
  begin
    if DebugState then
      Self.DebugLn('GetAlchItem: Failed to open inventory or deselect slot');
    Exit;
  end;

  if DebugState then
    Self.DebugLn('GetAlchItem: Searching for items from alch list (Total items in list: ' + ToStr(Length(Self.ItemArray)) + ')');

  if not ItemFinder.Find(Self.ItemArray, Inventory.GetSlotBoxes(), match) then
  begin
    Self.DebugLn('No items in the alch list were found!');
    Self.Disabled := True;
    Exit;
  end;

  Result := match.Item;
  itemStr := Result;

  Self.DebugLn('Found item: ' + itemStr);

  itemStr := itemStr.After('noted ');
  Self.LowProfit  := ItemData.GetLowAlchProfit(itemStr);
  Self.HighProfit := ItemData.GetHighAlchProfit(itemStr);
  
  if DebugState then
    Self.DebugLn('GetAlchItem: Low profit=' + ToStr(Self.LowProfit) + ', High profit=' + ToStr(Self.HighProfit));
end;

// Add profit to total
procedure TRSAlchHandler.AddProfit(hi: Boolean = True);
begin
  if hi then
    Self.TotalProfit += Self.HighProfit
  else
    Self.TotalProfit += Self.LowProfit;
end;

// Click an empty inventory slot
function TRSAlchHandler.ClickEmptySlot(slot: Int32 = -1): Boolean;
var
  slots: TIntegerArray;
begin
  slots := Inventory.GetEmptySlots();
  Result := slots <> [];

  if Result then
  begin
    if slot = -1 then
      slot := Inventory.Items.PointToSlot(Mouse.Position());

    if slot = -1 then
      Inventory.Items.MouseRandomSlot(slots)
    else
    begin
      if (slots.Find(slot) = -1) or Antiban.BioDice(50) then
        slot := Inventory.RandomSlotNearby(slot, slots);
      Inventory.MouseSlot(slot);
    end;
    Mouse.Click(MOUSE_LEFT);
  end;
end;

// Disable the alchemy cast
function TRSAlchHandler.DisableCast(): Boolean;
var
  i, attempt: Int32;
begin
  repeat
    if Inc(attempt) > 10 then
      Self.Fatal('Cannot disable the alchemy spell!');

    // Randomize method on each iteration
    if Inventory.Count() < 28 then
      i := SRL.TruncatedGauss(0, 5)
    else
      i := SRL.TruncatedGauss(3, 5);

    case i of
      0..2: Self.ClickEmptySlot();
      3: Mouse.Click(MainScreen.Bounds, MOUSE_LEFT);
      4: Mouse.Click(Chat.Bounds, MOUSE_LEFT);
      5: ChooseOption.Select('Cancel');
    end;
  until not MainScreen.IsUpText('Alchemy -');
  Result := True;
end;

// Select the alchemy spell
function TRSAlchHandler.SelectSpell(hi: Boolean = True): Boolean;
var
  attempt: Int32;
  spellStr: String;
  spell: ERSSpell;
begin
  if hi then
  begin
    spell := ERSSpell.HIGH_LEVEL_ALCHEMY;
    spellStr := 'h Level Alchemy -';
  end
  else
  begin
    spell := ERSSpell.LOW_LEVEL_ALCHEMY;
    spellStr := 'w Level Alchemy -';
  end;

  repeat
    if DebugState then
      Self.DebugLn('SelectSpell: Attempt ' + ToStr(attempt + 1) + ' - IsSelected: ' + ToStr(Magic.IsSelected(spell)) + ', InvOpen: ' + ToStr(Inventory.IsOpen()));
    
    if not Magic.IsSelected(spell) or
       not GameTabs.FKeyOpen(ERSGameTab.INVENTORY)
    then
    begin
      if DebugState then
        Self.DebugLn('SelectSpell: Casting spell...');
      Magic.CastSpell(spell);
    end;

    Result := MainScreen.IsUpText(spellStr) or Inventory.IsOpen();
    
    if DebugState then
      Self.DebugLn('SelectSpell: Result = ' + ToStr(Result) + ', UpText: ' + MainScreen.GetUpText());
  until Result or (Inc(attempt) > 3);

  Self.Disabled := not Result;
  
  if DebugState and not Result then
    Self.DebugLn('SelectSpell: FAILED after ' + ToStr(attempt) + ' attempts');
end;

// Select the item to alch
function TRSAlchHandler.SelectItem(hi: Boolean = True; waitTimer: Boolean = False): Boolean;
var
  attempt, slot, spellSlot: Int32;
  box: TBox;
  slots: TIntegerArray;
begin
  if hi then
    Self.Timer.Length := 5 * 600
  else
    Self.Timer.Length := 3 * 600;

  spellSlot := Self.SlotUnder;
  
  if DebugState then
    Self.DebugLn('SelectItem: Starting - SpellSlot=' + ToStr(spellSlot) + ', Item=' + ToStr(Self.Item));

  for attempt := 0 to 2 do
  begin
    if DebugState then
      Self.DebugLn('SelectItem: Attempt ' + ToStr(attempt + 1));
      
    if Self.Item.IsNull() then
    begin
      if DebugState then
        Self.DebugLn('SelectItem: Item is null, getting alch item...');
      Self.Item := Self.GetAlchItem();
    end;

    if Self.Item.IsNull() then
    begin
      if DebugState then
        Self.DebugLn('SelectItem: FAILED - No alch item found!');
      Exit;
    end;

    if Inventory.FindItem(Self.Item, slot) then
    begin
      if DebugState then
        Self.DebugLn('SelectItem: Found item in slot ' + ToStr(slot));
        
      if (slot <> spellSlot) and (Inventory.Items.CountStack(slot) > 0) then
      begin
        if DebugState then
          Self.DebugLn('SelectItem: Item not under spell, moving from slot ' + ToStr(slot) + ' to ' + ToStr(spellSlot));
        Self.DisableCast();
        if Inventory.Items.Move(slot, spellSlot) then
        begin
          if DebugState then
            Self.DebugLn('SelectItem: Item moved successfully');
          Exit;
        end;
        Break;
      end;

      if SRL.Dice(99.5) then
      begin
        if DebugState then
          Self.DebugLn('SelectItem: Mousing slot ' + ToStr(slot));
          
        if not Inventory.MouseSlot(slot) and not MainScreen.IsUpText('>') then
        begin
          if DebugState then
            Self.DebugLn('SelectItem: Failed to mouse slot');
          Exit;
        end;

        if not waitTimer then
        begin
          if not Self.Timer.IsFinished() and (Self.Timer.Timeout > 0) then
          begin
            if DebugState then
              Self.DebugLn('SelectItem: Timer not finished, waiting... (' + ToStr(Self.Timer.TimeRemaining()) + 'ms remaining)');
            Exit;
          end;
        end else
        begin
          if DebugState then
            Self.DebugLn('SelectItem: Waiting for timer to finish...');
          WaitUntil(Self.Timer.IsFinished(), 50, 3100);
        end;

        if DebugState then
          Self.DebugLn('SelectItem: Clicking item...');
        Mouse.Click(MOUSE_LEFT);

        if DebugState then
          Self.DebugLn('SelectItem: Waiting for XP or Magic tab...');
          
        if not WaitUntil(XPBar.EarnedXP() or Magic.IsOpen(), 300, 3000) then
        begin
          if DebugState then
            Self.DebugLn('SelectItem: No XP gained - cast may have failed');
          Exit;
        end;

        if DebugState then
          Self.DebugLn('SelectItem: SUCCESS - Alch cast complete!');
          
        Self.Timer.Restart();
        Self.AddProfit(hi);
        Exit(True);
      end;

      if DebugState then
        Self.DebugLn('SelectItem: Dice roll failed (0.5%), clicking nearby empty slot');
        
      slots := Inventory.GetEmptySlots();
      if slots <> [] then
      begin
        slot := Inventory.RandomSlotNearby(slot, slots);
        Inventory.ClickSlot(slot, '>');
      end;
      Exit;
    end
    else if ItemData.GetDefinitionBoolean(Self.Item, 'equipable') then
    begin
      if DebugState then
        Self.DebugLn('SelectItem: Item is equipable, checking equipment...');
      Self.DisableCast();
      if Equipment.FindItem(Self.Item, box) then
      begin
        if DebugState then
          Self.DebugLn('SelectItem: Found item in equipment, clicking to unequip');
        Mouse.Click(box, MOUSE_LEFT);
        Exit;
      end;
    end;

    if DebugState then
      Self.DebugLn('SelectItem: Resetting item to empty for next attempt');
    Self.Item := '';
  end;
  
  if DebugState then
    Self.DebugLn('SelectItem: FAILED after all attempts');
end;

// Main alchemy casting function
function TRSAlchHandler.CastAlchemy(hi: Boolean = True; waitTimer: Boolean = False): Boolean;
var
  attempt: Int32;
begin
  if DebugState then
    Self.DebugLn('========================================');
  if DebugState then
    Self.DebugLn('CastAlchemy: Starting - High=' + ToStr(hi) + ', WaitTimer=' + ToStr(waitTimer));
    
  XPBar.EarnedXP(); //Update cached XP.

  repeat
    if DebugState then
      Self.DebugLn('CastAlchemy: Main loop attempt ' + ToStr(attempt + 1));
      
    if DebugState then
      Self.DebugLn('CastAlchemy: Calling SelectSpell...');
      
    if not Self.SelectSpell(hi) then
    begin
      if DebugState then
        Self.DebugLn('CastAlchemy: SelectSpell FAILED - Exiting');
      Exit;
    end;
    
    if DebugState then
      Self.DebugLn('CastAlchemy: SelectSpell SUCCESS - Calling SelectItem...');
      
    Result := Self.SelectItem(hi, waitTimer);
    
    if DebugState then
      Self.DebugLn('CastAlchemy: SelectItem returned ' + ToStr(Result));
      
    TRSWalkerObject.RedClicked := False; //Integration with other wasplib components.
  until Result or (Inc(attempt) > 2);
  
  if DebugState then
  begin
    if Result then
      Self.DebugLn('CastAlchemy: COMPLETE - SUCCESS!')
    else
      Self.DebugLn('CastAlchemy: COMPLETE - FAILED after ' + ToStr(attempt) + ' attempts');
    Self.DebugLn('========================================');
  end;
end;

// Global handler instance (declared before override functions that use it)
var
  RSAlchHandler: TRSAlchHandler;

// Override Magic.FindSpell to track slot under spell
function TRSMagic.FindSpell(spell: ERSSpell; out box: TBox; attempts: Int32 = 2): Boolean; override;
var
  slots: TBoxArray;
  i: Int32;
begin
  Result := inherited(spell, box, attempts);

  if not Result then
    Exit;

  if (spell <> ERSSpell.LOW_LEVEL_ALCHEMY) and
     (spell <> ERSSpell.HIGH_LEVEL_ALCHEMY) then
    Exit;

  slots := Inventory.GetSlotBoxes();
  for i := 0 to High(slots) do
    if box.Overlap(slots[i]) then
    begin
      RSAlchHandler.SlotUnder := i;
      Exit;
    end;
end;

// Override Magic.MouseSpell for better alchemy handling
function TRSMagic.MouseSpell(spell: ERSSpell): Boolean; override;
var
  box: TBox;
  upText: String;
begin
  if (Self.SpellCache[spell].UpText <> '') and
     Self.SpellCache[spell].Box.Contains(Mouse.Position()) then
  begin
    upText := MainScreen.GetUpText().After('Cast').Before('/').Strip();

    if (upText = Self.SpellCache[spell].UpText) then
      Exit(True);
    if upText.Contains('>') then
    begin
      ChooseOption.Select('Cancel');
      Exit(Self.MouseSpell(spell));
    end;
  end;

  Result := Self.Open() and Self.FindSpell(spell, box);

  if Result then
  begin
    Mouse.Move(box);

    if Self.SpellCache[spell].UpText = '' then
    begin
      upText := MainScreen.GetUpText().After('Cast').Before('/').Strip();
      Self.SpellCache[spell].UpText := upText;
    end;
  end;
end;

// Setup handler on SRL initialization
procedure TSRL.Setup(); override;
begin
  inherited;
  RSAlchHandler.Setup();
end;

{$ENDIF}

