{******************************************************************************
 * SuperHeater - State Machine Module
 * 
 * This file contains state management logic - determining what state we're
 * in and what actions need to be taken.
 *****************************************************************************}

{******************************************************************************
 * TSuperHeater.HandleActivity
 * 
 * Handles overall activity status including script completion and level ups.
 * 
 * @return: The appropriate state based on activity status
 *****************************************************************************}
function TSuperHeater.HandleActivity(): EState;
begin
  if WL.Activity.IsFinished() then
    Result := EState.END_SCRIPT
  else if Chat.LeveledUp() then
  begin
    Self.SuperHeating := False;
    Result := EState.LEVEL_UP;
  end;
end;

{******************************************************************************
 * TSuperHeater.HandleBank
 * 
 * Determines the next action when the bank is open.
 * Checks for bars to deposit, required items, and inventory status.
 * 
 * @return: The appropriate state for bank operations
 *****************************************************************************}
function TSuperHeater.HandleBank(): EState;
var
  hasBar, hasPrimaryOre, hasSecondaryOre, hasRunes: Boolean;
  barCount, primaryOreCount, secondaryOreCount, runeCount: Int32;
  bankIsEmpty, hasAllRequired: Boolean;
begin
  WriteLn('========================================');
  WriteLn('HandleBank: Entering bank handler');
  WriteLn('========================================');
  
  // Check inventory status for all items
  hasBar := Inventory.ContainsItem(Self.Bar.Item);
  barCount := Inventory.CountItem(Self.Bar.Item);
  
  hasPrimaryOre := Inventory.ContainsItem(Self.PrimaryOre.Item);
  primaryOreCount := Inventory.CountItem(Self.PrimaryOre.Item);
  
  hasRunes := Inventory.ContainsItem(Self.Runes.Item);
  runeCount := Inventory.CountItem(Self.Runes.Item);
  
  // Check secondary ore if applicable
  if Self.SecondaryOre.Item <> '' then
  begin
    hasSecondaryOre := Inventory.ContainsItem(Self.SecondaryOre.Item);
    secondaryOreCount := Inventory.CountItem(Self.SecondaryOre.Item);
    WriteLn('  Secondary Ore (', Self.SecondaryOre.Item, '): ', hasSecondaryOre, ' (Count: ', secondaryOreCount, ')');
  end
  else
  begin
    hasSecondaryOre := True; // Not needed for this bar type
    secondaryOreCount := 0;
    WriteLn('  Secondary Ore: Not required for this bar type');
  end;
  
  // Display inventory status
  WriteLn('Inventory Status:');
  WriteLn('  Bar (', Self.Bar.Item, '): ', hasBar, ' (Count: ', barCount, ')');
  WriteLn('  Primary Ore (', Self.PrimaryOre.Item, '): ', hasPrimaryOre, ' (Count: ', primaryOreCount, ')');
  WriteLn('  Runes (', Self.Runes.Item, '): ', hasRunes, ' (Count: ', runeCount, ')');
  
  // Check bank status
  bankIsEmpty := Self.BankEmpty;
  hasAllRequired := Self.HasRequiredItems();
  
  WriteLn('Bank Status:');
  WriteLn('  Bank is empty: ', bankIsEmpty);
  WriteLn('  Has all required items: ', hasAllRequired);
  
  // Decision logic with detailed output
  WriteLn('Decision Logic:');
  
  // Priority 1: Deposit bars if we have them
  if hasBar then
  begin
    WriteLn('  -> Found ', barCount, ' bar(s) in inventory');
    WriteLn('  -> Decision: DEPOSIT_PRODUCT');
    Result := EState.DEPOSIT_PRODUCT;
  end
  // Priority 2: Check if bank is empty or we already have required items
  else if bankIsEmpty then
  begin
    WriteLn('  -> Bank is empty, no materials to withdraw');
    WriteLn('  -> Decision: CLOSE_INTERFACE');
    Result := EState.CLOSE_INTERFACE;
  end
  else if hasAllRequired then
  begin
    WriteLn('  -> Already have all required items');
    WriteLn('  -> Primary Ore: ', hasPrimaryOre);
    WriteLn('  -> Secondary Ore: ', hasSecondaryOre);
    WriteLn('  -> Runes: ', hasRunes);
    WriteLn('  -> Decision: CLOSE_INTERFACE');
    Result := EState.CLOSE_INTERFACE;
  end
  // Priority 3: Withdraw materials if we don't have everything
  else if not hasAllRequired then
  begin
    WriteLn('  -> Missing required items:');
    if not hasPrimaryOre then
      WriteLn('     * Missing Primary Ore (', Self.PrimaryOre.Item, ')');
    if not hasSecondaryOre and (Self.SecondaryOre.Item <> '') then
      WriteLn('     * Missing Secondary Ore (', Self.SecondaryOre.Item, ')');
    if not hasRunes then
      WriteLn('     * Missing Runes (', Self.Runes.Item, ')');
    WriteLn('  -> Decision: WITHDRAW_MATERIAL');
    Result := EState.WITHDRAW_MATERIAL;
  end
  // Default fallback
  else
  begin
    WriteLn('  -> No specific condition met (fallback)');
    WriteLn('  -> Decision: CLOSE_INTERFACE');
    Result := EState.CLOSE_INTERFACE;
  end;
  
  // Update item count for tracking
  ItemCount := primaryOreCount;
  WriteLn('Updated ItemCount to: ', ItemCount);
  WriteLn('========================================');
  WriteLn('');
end;

{******************************************************************************
 * TSuperHeater.HandleCollects
 * 
 * Determines the next action when the collection box is open.
 * 
 * @return: The appropriate state for collection box operations
 *****************************************************************************}
function TSuperHeater.HandleCollects(): EState;
var
  collectEmpty, hasItems: Boolean;
begin
  collectEmpty := Self.CollectEmpty;
  hasItems := HasRequiredItems();
  
  WriteLn('Self.CollectEmpty: ', collectEmpty);
  WriteLn('HasRequiredItems(): ', hasItems);
  
  if collectEmpty or hasItems then
    Result := EState.CLOSE_INTERFACE
  else
    Result := EState.HANDLE_COLLECT;
end;

{******************************************************************************
 * TSuperHeater.GetState
 * 
 * Main state machine logic. Determines the current state based on various
 * conditions including interfaces, inventory, and activity status.
 * 
 * @return: The current state that needs to be processed
 *****************************************************************************}
function TSuperHeater.GetState(): EState;
begin
  // Handle critical activities first (completion, level ups)
  if WL.Activity.IsFinished() or Chat.LeveledUp() then
    Exit(HandleActivity());

  // Check for consecutive spell casting failures
  if (Self.SpellCastFailed >= CastAttemptReset) then
  begin
    WriteLn('Too many failed cast attempts (', Self.SpellCastFailed, '), returning to bank');
    Self.SpellCastFailed := 0; // Reset the counter after handling
    Exit(OPEN_BANK);
  end;

  // Handle different interfaces
  if RSInterface.IsOpen() then
  begin
    Self.SuperHeating := False; // Reset the flag
    
    if Bank.IsOpen() then
      Exit(HandleBank());

    if CollectBox.IsOpen() then
      Exit(HandleCollects());

    Exit(EState.CLOSE_INTERFACE);
  end;

  // Check if there are no items left to process
  if ItemCount <= 0 then
  begin
    WriteLn('No items remaining, opening bank');
    Exit(EState.OPEN_BANK);
  end;

  // Default to casting spell if other conditions are not met
  Exit(EState.CAST_SPELL);
end;
